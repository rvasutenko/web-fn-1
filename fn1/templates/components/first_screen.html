{% load static %}

<div class="first-screen__container">
    <canvas id="graphCanvas"></canvas>
    <!-- <img class="first-screen__bg" src="{% static 'img/first-screen-bg.jpg' %}" alt=""> -->
    <div class="first-screen__content">
        <h1 class="first-screen__title">Кафедра ФН1</h1>
        <span class="first-screen__subtitle">Высшая математика</span>
    </div>
    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        
        // Настройка размеров
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        
        // Цветовая палитра
        const colors = {
            accent: '#8C2CFF',
            dark: '#39126A',
            black: '#1A1A19',
            white: '#FFFFFF'
        };
        
        // Параметры графа
        const nodes = [];
        const numNodes = 80;
        const minDistance = 150;
        const nodeSize = 5;
        
        // Создание узлов
        for (let i = 0; i < numNodes; i++) {
            nodes.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 1.2,
                vy: (Math.random() - 0.5) * 1.2,
                color: Math.random() > 0.3 ? colors.accent : colors.dark,
                rotationSpeed: (Math.random() - 0.5) * 0.02,
                angle: Math.random() * Math.PI * 2
            });
        }
        
        // Функция для рисования квадрата
        function drawSquare(x, y, size, color, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = color;
            ctx.fillRect(-size/2, -size/2, size, size);
            ctx.strokeStyle = colors.black;
            ctx.lineWidth = 1;
            ctx.strokeRect(-size/2, -size/2, size, size);
            ctx.restore();
        }
        
        // Функция для преобразования HEX в RGBA
        function hexToRgba(hex, opacity) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }
        
        // Анимация
        let lastTime = performance.now();
        function animate(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Обновление позиций узлов
            nodes.forEach(node => {
                node.x += node.vx;
                node.y += node.vy;
                
                if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
                if (node.y < 0 || node.y > canvas.height) node.vy *= -1;
                
                if (Math.random() < 0.005) {
                    node.vx += (Math.random() - 0.5) * 0.3;
                    node.vy += (Math.random() - 0.5) * 0.3;
                }
                
                // Обновление угла вращения
                node.angle += node.rotationSpeed * deltaTime * 0.05;
            });
            
            // Рисование связей
            ctx.lineWidth = 1.2;
            nodes.forEach((node1, i) => {
                nodes.slice(i + 1).forEach(node2 => {
                    const dx = node2.x - node1.x;
                    const dy = node2.y - node1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < minDistance) {
                        const opacity = 1 - dist / minDistance;
                        ctx.strokeStyle = hexToRgba(colors.accent, opacity * 0.6);
                        ctx.beginPath();
                        ctx.moveTo(node1.x, node1.y);
                        ctx.lineTo(node2.x, node2.y);
                        ctx.stroke();
                    }
                });
            });
            
            // Рисование узлов
            nodes.forEach(node => {
                drawSquare(node.x, node.y, nodeSize, node.color, node.angle);
            });
            
            requestAnimationFrame(animate);
        }
        
        // Запуск анимации
        animate(lastTime);
        
        // Обработчик изменения размера окна
        window.addEventListener('resize', () => {
            resizeCanvas();
        });
    </script>
</div>